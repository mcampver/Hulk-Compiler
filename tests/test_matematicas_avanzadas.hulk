// ===================================================================
// TEST DE FUNCIONES MATEM√ÅTICAS BUILT-IN - HULK COMPILER
// Demuestra todas las capacidades matem√°ticas avanzadas
// ===================================================================

type ScientificCalculator {
    precision = 6;
    angleMode = "radians";  // "radians" or "degrees"
    
    init(precision, mode) {
        self.precision := precision;
        self.angleMode := mode;
    }
    
    // ==================== FUNCIONES TRIGONOM√âTRICAS ====================
    
    sinDeg(degrees) => sin(degrees * PI / 180.0);
    cosDeg(degrees) => cos(degrees * PI / 180.0);
    tanDeg(degrees) => self.sinDeg(degrees) / self.cosDeg(degrees);
    
    // Funciones trigonom√©tricas avanzadas
    sec(angle) => 1.0 / cos(angle);
    csc(angle) => 1.0 / sin(angle);
    cot(angle) => cos(angle) / sin(angle);
    
    // ==================== CONSTANTES MATEM√ÅTICAS ====================
    
    getPI() => PI;
    getE() => E;
    getGoldenRatio() => (1.0 + sqrt(5.0)) / 2.0;
    getEulerMascheroni() => 0.5772156649015329;  // Aproximaci√≥n
    
    // ==================== OPERACIONES AVANZADAS ====================
    
    // Logaritmos (aproximaciones)
    ln(x) => {
        // Aproximaci√≥n usando serie de Taylor para ln(1+x) donde x est√° cerca de 0
        let adjusted = (x - 1.0) / (x + 1.0) in
        let result = 2.0 * (adjusted + pow(adjusted, 3)/3.0 + pow(adjusted, 5)/5.0) in
        result
    };
    
    log10(x) => self.ln(x) / self.ln(10.0);
    log2(x) => self.ln(x) / self.ln(2.0);
    
    // Potencias y ra√≠ces
    cbrt(x) => pow(x, 1.0/3.0);  // Ra√≠z c√∫bica
    nthRoot(x, n) => pow(x, 1.0/n);
    
    // Funciones hiperb√≥licas
    sinh(x) => (pow(E, x) - pow(E, 0.0 - x)) / 2.0;
    cosh(x) => (pow(E, x) + pow(E, 0.0 - x)) / 2.0;
    tanh(x) => self.sinh(x) / self.cosh(x);
    
    // ==================== ESTAD√çSTICAS Y COMBINATORIA ====================
    
    factorial(n) => if (n <= 1) 1 else n * self.factorial(n - 1);
    
    combination(n, r) => self.factorial(n) / (self.factorial(r) * self.factorial(n - r));
    permutation(n, r) => self.factorial(n) / self.factorial(n - r);
    
    // N√∫meros de Fibonacci
    fibonacci(n) => if (n <= 1) n else self.fibonacci(n-1) + self.fibonacci(n-2);
    
    // ==================== APROXIMACIONES NUM√âRICAS ====================
    
    // Aproximaci√≥n de PI usando serie de Leibniz
    approximatePI(terms) => {
        let result = 0.0 in
        let i = 0 in {
            while (i < terms) {
                let term = 1.0 / (2.0 * i + 1.0) in
                let sign = if (i % 2 == 0) 1.0 else -1.0 in {
                    result := result + sign * term;
                    i := i + 1;
                };
            };
            4.0 * result
        }
    };
    
    // Aproximaci√≥n de E usando serie
    approximateE(terms) => {
        let result = 1.0 in
        let i = 1 in {
            while (i <= terms) {
                result := result + 1.0 / self.factorial(i);
                i := i + 1;
            };
            result
        }
    };
    
    // ==================== AN√ÅLISIS NUM√âRICO ====================
    
    // M√©todo de Newton-Raphson simplificado para sqrt
    newtonSqrt(x, iterations) => {
        let guess = x / 2.0 in
        let i = 0 in {
            while (i < iterations) {
                guess := (guess + x / guess) / 2.0;
                i := i + 1;
            };
            guess
        }
    };
    
    // Suma de series geom√©tricas
    geometricSeries(a, r, n) => {
        let sum = 0.0 in
        let i = 0 in {
            while (i < n) {
                sum := sum + a * pow(r, i);
                i := i + 1;
            };
            sum
        }
    };
    
    // ==================== FORMATEO Y UTILIDADES ====================
    
    format(number) => {
        // Simulaci√≥n de formateo con precisi√≥n
        if (self.precision == 2) {
            str(number) @ " (¬±0.01)"
        } else if (self.precision == 4) {
            str(number) @ " (¬±0.0001)"
        } else {
            str(number) @ " (precision:" @ str(self.precision) @ ")"
        }
    };
    
    formatAngle(radians) => {
        if (self.angleMode == "degrees") {
            str(radians * 180.0 / PI) @ "¬∞"
        } else {
            str(radians) @ " rad"
        }
    };
}

// ======================= FUNCIONES DE DEMOSTRACI√ìN =======================

function demonstrateTrigonometry() => {
    print("=== FUNCIONES TRIGONOM√âTRICAS ===");
    let calc = new ScientificCalculator(4, "degrees") in {
        
        // √Ångulos especiales
        let angles = [0.0, 30.0, 45.0, 60.0, 90.0] in  // Simulaci√≥n de array
        
        print("Funciones trigonom√©tricas para √°ngulos especiales:");
        print("0¬∞:  sin=" @ calc.format(calc.sinDeg(0.0)) @ 
              " cos=" @ calc.format(calc.cosDeg(0.0)));
        print("30¬∞: sin=" @ calc.format(calc.sinDeg(30.0)) @ 
              " cos=" @ calc.format(calc.cosDeg(30.0)));
        print("45¬∞: sin=" @ calc.format(calc.sinDeg(45.0)) @ 
              " cos=" @ calc.format(calc.cosDeg(45.0)));
        print("60¬∞: sin=" @ calc.format(calc.sinDeg(60.0)) @ 
              " cos=" @ calc.format(calc.cosDeg(60.0)));
        print("90¬∞: sin=" @ calc.format(calc.sinDeg(90.0)) @ 
              " cos=" @ calc.format(calc.cosDeg(90.0)));
        
        // Identidades trigonom√©tricas
        let angle = 30.0 in
        let sin2_cos2 = pow(calc.sinDeg(angle), 2) + pow(calc.cosDeg(angle), 2) in
        print("Identidad sin¬≤Œ∏ + cos¬≤Œ∏ = " @ calc.format(sin2_cos2) @ " (debe ser ‚âà1)");
        
        // Funciones trigonom√©tricas inversas (aproximaciones)
        print("tan(45¬∞) = " @ calc.format(calc.tanDeg(45.0)) @ " (debe ser ‚âà1)");
    }
};

function demonstrateExponentials() => {
    print("=== FUNCIONES EXPONENCIALES Y LOGAR√çTMICAS ===");
    let calc = new ScientificCalculator(6, "radians") in {
        
        print("Constantes fundamentales:");
        print("œÄ = " @ calc.format(calc.getPI()));
        print("e = " @ calc.format(calc.getE()));
        print("œÜ (Golden Ratio) = " @ calc.format(calc.getGoldenRatio()));
        
        print("Operaciones exponenciales:");
        print("e^1 = " @ calc.format(pow(E, 1.0)));
        print("e^œÄ = " @ calc.format(pow(E, PI)));
        print("2^10 = " @ calc.format(pow(2.0, 10.0)));
        print("œÄ^e = " @ calc.format(pow(PI, E)));
        
        print("Ra√≠ces:");
        print("‚àö16 = " @ calc.format(sqrt(16.0)));
        print("‚àõ27 = " @ calc.format(calc.cbrt(27.0)));
        print("‚Å¥‚àö81 = " @ calc.format(calc.nthRoot(81.0, 4.0)));
        
        print("Funciones hiperb√≥licas:");
        print("sinh(1) = " @ calc.format(calc.sinh(1.0)));
        print("cosh(1) = " @ calc.format(calc.cosh(1.0)));
        print("tanh(1) = " @ calc.format(calc.tanh(1.0)));
        
        // Verificar identidad hiperb√≥lica
        let cosh2_sinh2 = pow(calc.cosh(1.0), 2) - pow(calc.sinh(1.0), 2) in
        print("cosh¬≤(1) - sinh¬≤(1) = " @ calc.format(cosh2_sinh2) @ " (debe ser ‚âà1)");
    }
};

function demonstrateApproximations() => {
    print("=== APROXIMACIONES NUM√âRICAS ===");
    let calc = new ScientificCalculator(8, "radians") in {
        
        print("Aproximaciones de constantes:");
        let piApprox = calc.approximatePI(1000) in
        print("œÄ aproximado (1000 t√©rminos): " @ calc.format(piApprox));
        print("œÄ real: " @ calc.format(PI));
        print("Error: " @ calc.format(piApprox - PI));
        
        let eApprox = calc.approximateE(20) in
        print("e aproximado (20 t√©rminos): " @ calc.format(eApprox));
        print("e real: " @ calc.format(E));
        print("Error: " @ calc.format(eApprox - E));
        
        print("M√©todo de Newton para ‚àö50:");
        let newtonResult = calc.newtonSqrt(50.0, 10) in
        let realResult = sqrt(50.0) in
        print("Resultado Newton: " @ calc.format(newtonResult));
        print("Resultado real: " @ calc.format(realResult));
        print("Error: " @ calc.format(newtonResult - realResult));
    }
};

function demonstrateCombinatorics() => {
    print("=== COMBINATORIA Y FACTORIALES ===");
    let calc = new ScientificCalculator(0, "radians") in {
        
        print("Factoriales:");
        print("5! = " @ str(calc.factorial(5)));
        print("8! = " @ str(calc.factorial(8)));
        print("10! = " @ str(calc.factorial(10)));
        
        print("Combinaciones C(n,r):");
        print("C(10,3) = " @ str(calc.combination(10, 3)));
        print("C(8,5) = " @ str(calc.combination(8, 5)));
        
        print("Permutaciones P(n,r):");
        print("P(10,3) = " @ str(calc.permutation(10, 3)));
        print("P(8,5) = " @ str(calc.permutation(8, 5)));
        
        print("Secuencia de Fibonacci:");
        print("F(0) a F(15):");
        let i = 0 in {
            while (i <= 15) {
                print("F(" @ str(i) @ ") = " @ str(calc.fibonacci(i)));
                i := i + 1;
            }
        }
    }
};

function demonstrateComplexCalculations() => {
    print("=== C√ÅLCULOS COMPLEJOS COMBINADOS ===");
    let calc = new ScientificCalculator(4, "radians") in {
        
        // Ecuaci√≥n compleja que combina m√∫ltiples funciones
        let complexResult = 
            pow(E, PI * calc.sinDeg(30.0)) + 
            sqrt(calc.factorial(5)) * calc.cosDeg(60.0) +
            calc.ln(calc.getGoldenRatio()) * pow(PI, 1.5) +
            calc.sinh(1.0) * calc.cosh(1.0) * calc.tanh(0.5)
        in {
            print("Resultado ultra-complejo:");
            print("e^(œÄ√ósin(30¬∞)) + ‚àö(5!)√ócos(60¬∞) + ln(œÜ)√óœÄ^1.5 + sinh(1)√ócosh(1)√ótanh(0.5)");
            print("= " @ calc.format(complexResult));
        };
        
        // Serie geom√©trica
        let geoSeries = calc.geometricSeries(2.0, 0.5, 10) in
        print("Serie geom√©trica 2√ó(1 + 0.5 + 0.5¬≤ + ... + 0.5‚Åπ) = " @ calc.format(geoSeries));
        
        // Aproximaci√≥n de integral usando suma de Riemann (simulada)
        let integral_approx = 
            let sum = 0.0 in
            let dx = 0.01 in
            let x = 0.0 in {
                while (x <= 1.0) {
                    sum := sum + sin(PI * x) * dx;  // ‚à´‚ÇÄ¬π sin(œÄx) dx
                    x := x + dx;
                };
                sum
            }
        in
        print("‚à´‚ÇÄ¬π sin(œÄx) dx ‚âà " @ calc.format(integral_approx) @ " (exacto: 2/œÄ ‚âà 0.6366)");
    }
};

// ======================= PROGRAMA PRINCIPAL =======================

print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
print("‚ïë         HULK COMPILER - FUNCIONES MATEM√ÅTICAS AVANZADAS     ‚ïë");
print("‚ïë              Demostrando capacidades cient√≠ficas            ‚ïë");
print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
print("");

demonstrateTrigonometry();
print("");

demonstrateExponentials();
print("");

demonstrateApproximations();
print("");

demonstrateCombinatorics();
print("");

demonstrateComplexCalculations();
print("");

print("üßÆ TODAS LAS FUNCIONES MATEM√ÅTICAS VERIFICADAS EXITOSAMENTE üßÆ");
print("‚úÖ Trigonometr√≠a: sin, cos, tan y funciones inversas");
print("‚úÖ Exponenciales: pow, sqrt, cbrt, funciones hiperb√≥licas");
print("‚úÖ Constantes: œÄ, e, œÜ (golden ratio)");
print("‚úÖ Combinatoria: factorial, combinaciones, permutaciones");
print("‚úÖ Secuencias: Fibonacci, series geom√©tricas");
print("‚úÖ Aproximaciones: M√©todos num√©ricos avanzados");
print("‚úÖ C√°lculos complejos: Ecuaciones multi-funci√≥n");
print("");
print("üöÄ HULK COMPILER - CALCULADORA CIENT√çFICA COMPLETA üöÄ");
